---
layout: post
title:  "3 编码、加密、Hash、序列化和字符集"
date:   2018-10-12 09:15:00 +0800
categories: HenCoder
tags: HenCoder_plus
author: pepe
description: 『 编码、加密、Hash、序列化和字符集 』
---

### 加密

* 木棒

* 替换

### 对称加密

* DES(秘钥太短，已经弃用)

* AES

* 特点：只有一个秘钥。

原文 + 秘钥，配合加密算法 = 密文

密文 + 秘钥，配合解密算法 = 原文

简单来说就是；

* 加密：A + 10 = K，10就是秘钥，加密算法是：原文 + 秘钥

* 解密：k - 10 = A，解密算法是：密文 - 秘钥


最有算法：只能在可能的范围内，穷举

破解：先拿到一组原文密文对，然后使用(试错)秘钥，对密文进行还原，如能还原成原文，那么破解成功。

### 非对称加密

> 非对称加密：公钥(加密秘钥)加密，私钥(解密秘钥)解密。利用溢出，来实现加密算法的一致。

原文 + 公钥，配合加密算法 = 密文

密文 + 私钥，配合加密算法 = 原文

关键点就是要保护好私钥。

简单来说就是；

* 加密：A + 25 = Z，25就是公钥，加密算法是：原文 + 公钥

* 解密：Z + 1  = A，1 就是私钥，解密算法是：密文 + 私钥，利用溢出。

公钥能解开私钥吗？

* 加密：A + 1  = B，1 就是私钥，加密算法是：原文 + 私钥

* 解密：B + 25 = A，25就是公钥，解密算法是：密文 + 公钥，利用溢出。

所以是可以的。公钥有时候可以被计算出来，所以不能换。转换上有对等关系，但有时候公钥是通过私钥算出来的。

经典算法：RSA(用于加密解密和签名验证都可以)、DSA(专门用来设计签名，速度有优势)

破解：不需要原文密文对，只使用(试错)私钥，对公钥进行破解，即可。破解私钥就行了，公钥是公开的，原文密文对都可以自己造。

### 数字签名(非对称加密的应用)

原数据   + 私钥，配合加密算法 = 签名数据

签名数据 + 公钥，配合加密算法 = 原数据

签名数据没有私钥是没法伪造的。用于签名和验证。

### 加密 + 签名

![2_1]({{ site.baseurl }}/assets/images/Hencoder/hencoder2_1.png)

### 秘钥和登录密码

秘钥

* 场景：用于加密和解密

* 目的：保证数据被盗时不会被人读懂内容

* 焦点：数据

登录密码

* 场景：用于进入网站或游戏前的身份验证

* 目的：数据提供方或应用服务方对账户拥有者数据的保护，保证「你是你」的时候才提供权限

* 焦点：身份

### Base64

A-Z、a-z、0-9、+、/，合计64个字符。并不是加密，仅仅是一个转换的算法而已。

目的：把二进制数据转换成字符串。

转换之后，字符长度反而变长了。

用途：

* 让原数据具有字符串所具有的的特性，如：可以放在URL中传输、可以保存在文本文件、可以通过普通的聊天软件进行文本传输。

* 把原本人眼可以读懂的字符串变成读不懂的字符串，降低偷窥风险

「Base64加密传输图片，可以更安全和高效」，真的吗？
no，no。

Base58：删除了 0(数字0)和大写0(o、O)，大写I(i、I)和小写l(l、L)，还有 +和/。

### Hash

> Hash：把任意数据转换成指定大小范围(通常很小)的数据。

* 作用：摘要、数字指纹

* 经典算法：MD5、SHA1、SHA256等

* 实际用途：数据完整性验证、快速查找(hashCode()和equals())、隐私保护(对密码进行hash(),再MD5，不保存原文)

> 为什么重写了equals()，就一定要重写hashCode()吗?Object的默认equals()方法是比较内存地址。所以你重写了equals()方法，是本来不同的两个对象，变得相同了。hashCode()，我们知道是求散列值，也就是摘要了。说说HashMap，如果我们重写了equals()的对象作为value，那么无影响。如果是作为key呢？HashMap是如何区分两个key呢？在插入时，使用对象的hashCode()作为key保存对象。在查询时，首先会比较hashCode()，如果相等继续比较equals()。而我们的本意，重写equals()的目的，就是让两个不同的Object，可以认定为是同一个Object。现在，两个你认为是相同的Object，在分别插入到HashMap时，两个对象都会保存，因为hashCode()不同嘛。在插入一个之后，想要通过另一个来获取value，也会找不到。所以如果你重写了equals()，那么最好也重写一下hashCode()。这样，在使用该对象作为HashMap的key时，就不会出现意想不到的情况了。

Hash是编码吗？

> 不是。Hash是单向过程，往往是不可逆的，无法进行逆向恢复操作，因此Hash不属于编码。图片2M，hash值只有2k。

Hash是加密吗？

> 不是。Hash是单向过程，无法进行逆向回复操作，因此Hash不属于加密。(记住，MD5不是加密！)图片2M，hash值只有2k。

![2_2]({{ site.baseurl }}/assets/images/Hencoder/hencoder2_2.png)