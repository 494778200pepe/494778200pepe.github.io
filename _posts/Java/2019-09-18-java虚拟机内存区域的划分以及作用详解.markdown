---
layout: post
title:  "java虚拟机内存区域的划分以及作用详解"
date:   2019-09-18 13:44:00 +0800
categories: Java
tags: Java基础
author: pepe
description: 『 java虚拟机内存区域的划分以及作用详解 』
---

### **运行时数据区**

![memory1]({{ site.baseurl }}/assets/images/java/memory1.png)

* 1、(线程不共享)程序计数器(寄存器)　　

	。 当前线程所执行的字节码行号指示器
	。 字节码解释器工作依赖计数器控制完成
	。 通过执行线程行号记录，让线程轮流切换各条线程之间计数器互不影响
	。 线程私有，生命周期与线程相同，随JVM启动而生，JVM关闭而死
	。 线程执行Java方法时，记录其正在执行的虚拟机字节码指令地址
	。 线程执行Nativan方法时，计数器记录为空（Undefined）
	。 唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域
	
> 在这其中，很多不理解的没关系，我们学过多线程，有两个线程，其中一个线程可以暂停使用，让其他线程运行，然后等自己获得cpu资源时，又能从暂停的地方开始运行，那么为什么能够记住暂停的位置的，这就依靠了程序计数器， 通过这个例子，大概了解一下程序计数器的功能。　　　
　　　　　　　　　
* 2、(线程不共享)本地方法栈

> 不知道大家看过源码没有，看过的都应该知道，很多的算法或者一个功能的实现，都被java封装到了本地方法中，程序直接通过调用本地的方法就行了，本地方法栈就是用来存放这种方法的，实现该功能的代码可能是C也可能是C++,反正不一定就是java实现的。

* 3、(线程不共享)虚拟机栈

	。 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用来存放存储局部变量表、操作数表、动态连接、方法出口等信息，
	。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 
	
	以上说的三个都是线程不共享的，也就是这部分内存，每个线程独有，不会让别的线程访问到，接下来的两个就是线程共享了，也就会出现线程安全问题。
	
* 4、堆

	。 所有线程共享的一块内存区域。Java虚拟机所管理的内存中最大的一块，因为该内存区域的唯一目的就是存放对象实例。
	。 几乎所有的对象实例度在这里分配内存，也就是通常我们说的new对象，该对象就会在堆中开辟一块内存来存放对象中的一些信息，比如属性呀什么的。
	。 同时堆也是垃圾收集器管理的主要区域。因此很多时候被称为"GC堆"，虚拟机的垃圾回收机制等下一篇文章来讲解。 
	。 在上一点讲的栈中存放的局部引用变量所指向的大多数度会在堆中存放。
	
* 5、方法区和其中的运行时常量池

	。 和堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、和编译器编译后的代码(也就是存储字节码文件。.class)等数据，
	。 这里可以看到常量也会在方法区中，是因为方法区中有一个运行时常量池，
	。 为什么叫运行时常量池，因为在编译后期生成的是各种字面量(字面量的意思就是值，比如int i=3，这个3就是字面量的意思)和符号引用，
	。 这些是存放在一个叫做常量池(这个常量池是在字节码文件中)的地方，当类加载进入方法区时，就会把该常量池中的内容放入运行时常量池中。
	。 这里要注意，运行时常量池和常量池，不要搞混淆了，字节码文件中也有常量池，在后面的章节会详细讲解这个东西。
	。 现在只需要知道方法区中有一个运行时常量池，就是用来存放常量的。
	。 还有一点，运行时常量池不一定就一定要从字节码常量池中拿取常量，可能在程序运行期间将新的常量放入池中，
	。 比如String.intern()方法，这个方法的作用就是：先从方法区的运行时常量池中查找看是否有该值，如果有，则返回该值的引用，如果没有，那么就会将该值加入运行时常量池中。


![memory2]({{ site.baseurl }}/assets/images/java/memory2.png)

java虚拟机内存区域的划分以及作用详解 - 豁然高 - 博客园
https://www.cnblogs.com/gaoBlog/p/10842526.html


* 方法区：类信息、类变量（静态变量和常量）、方法 
* 堆：对象、成员变量 
* 栈：局部变量 

	。 （1）当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类变量、类常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！ 
	。 （2）当程序中new一个对象时，这个对象存在堆中，对象的变量存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！ 
	。 （3）当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！

类变量：属于类的属性信息，与类的实例无关，多个实例共用同一个类变量，存在与方法区中。类变量用static修饰，包括静态变量和常量。静态变量有默认初始值，常量必须声明同时初始化。

成员变量：属于实例的变量，只与实例有关，写在类下面，方法外，非static修饰。成员变量会随着成员的创建而生存，随着成员的回收而销毁。

局部变量：声明在方法中，没有默认初始值，随着方法的调用而创建，存储于栈中，随着方法调用的结束而销毁。

java 堆、栈、方法区／ 类变量、成员变量、局部变量 - Andy_alone - 博客园
https://www.cnblogs.com/andy-alone/p/9217283.html

### **对于Java静态内部类的理解**

* 非静态内部类是附属在『外部类对象』上的，需要先实例化一个『外部类的对象』，通过外部类对象才能实例化非静态内部类；
* 而静态内部类可以看做是直接附属在『外部类』上的，这个静态代表附属体是『外部类』，而不是外部类实例；
* 外部类在进程中是唯一的，而静态内部类不需要唯一，可以生成多个实例。

```
public class outClass {
    public static class innerClass{
        public innerClass(){
            System.out.println("innerClass");
        }
    }
    public static void main(String[] args) 
    { 
        //outClass a = new outClass();
        innerClass b = new innerClass();
        innerClass c = new innerClass();        
    }
}

public class outClass {
    public class innerClass{
        public innerClass(){
            System.out.println("innerClass");
        }
    }
    public static void main(String[] args) 
    { 
        outClass a = new outClass();
        innerClass b = a.new innerClass();
        innerClass c = a.new innerClass();   
    }
}
```
对于Java静态内部类的理解 - 风生水起 - 博客园
https://www.cnblogs.com/end/archive/2012/12/21/2827672.html




































