---
layout: post
title:  "泛型"
date:   2018-04-09 13:13:00 +0800
categories: Java
tags: Java基础
author: pepe
description: 『 泛型 』
---

### **泛型**

* 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。
* 那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化。
* 类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

### **泛型本质**

* 在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型。
* 传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型。
* 当然，在逻辑上我们可以理解成多个不同的泛型类型。
* 究其原因，在于Java中的泛型这一概念提出的目的，只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦。
* 也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。

对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。

### **泛型和子类型**
为了彻底理解泛型，这里看个例子：（Apple为Fruit的子类）

```
List<Apple> apples = new ArrayList<Apple>(); //1  
List<Fruit> fruits = apples; //2 
``` 
 
* 第1行代码显然是对的，但是第2行是否对呢？
* 我们知道`Fruit fruit = new Apple()`，这样肯定是对的，即苹果肯定是水果，但是第2行在编译的时候会出错。
* 这会让人比较纳闷的是一个苹果是水果，为什么一箱苹果就不是一箱水果了呢？
* 可以这样考虑，我们假定第2行代码没有问题，那么我们可以使用语句
* `fruits.add(new Strawberry())`（Strawberry为Fruit的子类）在fruits中加入草莓了，
* 但是这样的话，一个List中装入了各种不同类型的子类水果，这显然是不可以的。
* 因为我们在取出List中的水果对象时，就分不清楚到底该转型为苹果还是草莓了。

通常来说，如果 Apple 是 Fruit 的子类型，G是一种带泛型的类型，则G<Apple>不是G<Fruit>的子类型。这也许是泛型学习里面最让人容易混淆的一点。

### **泛型类**
```
public class Container<K, V> {
    private K key;
    private V value;

    public Container(K k, V v) {
        key = k;
        value = v;
    }

    public K getKey() {
        return key;
    }

    public void setKey(K key) {
        this.key = key;
    }

    public V getValue() {
        return value;
    }

    public void setValue(V value) {
        this.value = value;
    }
}
```

### **泛型接口**
在泛型接口中，生成器是一个很好的理解，看如下的生成器接口定义：
```
public interface Generator<T> {
    public T next();
}
```
然后定义一个生成器类来实现这个接口：
```
public class FruitGenerator implements Generator<String> {

    private String[] fruits = new String[]{"Apple", "Banana", "Pear"};

    @Override
    public String next() {
        Random rand = new Random();
        return fruits[rand.nextInt(3)];
    }
}
```
调用：
```
public class Main {

    public static void main(String[] args) {
        FruitGenerator generator = new FruitGenerator();
        System.out.println(generator.next());
        System.out.println(generator.next());
        System.out.println(generator.next());
        System.out.println(generator.next());
    }
}
```
输出：
```
Banana
Banana
Pear
Banana
```

### **泛型方法**

* 一个基本的原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法。
* 也就是说，如果使用泛型方法可以取代将整个类泛化，那么应该有限采用泛型方法。

下面来看一个简单的泛型方法的定义：
```
public class Main {

    public static <T> void out(T t) {
        System.out.println(t);
    }

    public static void main(String[] args) {
        out("findingsea");
        out(123);
        out(11.11);
        out(true);
    }
}
```

### **`<? extends T>`**

`<? extends T>`表示类型的上界，表示参数化类型的可能是T 或是 T的子类

### **`<? super T>`**

`<? super T>`表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object

### **注意**

1、`List<String>`和`List<Integer>`是同一类型
```
/*会导致编译时错误*/   
public class Erasure{  
    public void test(List<String> ls){  
        System.out.println("Sting");  
    }  
    
    public void test(List<Integer> li){  
        System.out.println("Integer");  
    }  
}  
```

2、泛型数组


参考：

[Java泛型编程最全总结 - 切梦 - ITeye博客](http://qiemengdao.iteye.com/blog/1525624)
