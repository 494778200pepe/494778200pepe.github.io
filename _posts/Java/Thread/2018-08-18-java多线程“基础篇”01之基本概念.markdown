---
layout: post
title:  "java多线程“基础篇”01之基本概念"
date:   2018-08-18 10:50:00 +0800
categories: Java
tags: Java多线程
author: pepe
description: 『 基本概念 』
---

## **线程状态图**
![thread01]({{ site.baseurl }}/assets/images/java/thread/thread01.png)

## **说明**

线程共包括以下5种状态。

* 1、新建状态(New)         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。
* 2、就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。
* 3、运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。
* 4、阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
    
    。 (01) 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。
    
    。 (02) 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
    
    。 (03) 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

* 5、死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。


这5种状态涉及到的内容包括`Object`类, `hread`和`synchronized`关键字。这些内容我们会在后面的章节中逐个进行学习。

* `Object类`，定义了`wait()`, `notify()`, `notifyAll()`等休眠/唤醒函数。

* `Thread类`，定义了一些列的线程操作函数。例如，`sleep()`休眠函数, `interrupt()`中断函数, `getName()`获取线程名称等。

* `synchronized`，是关键字；它区分为`synchronized代码块`和`synchronized方。s`ynchronized`的作用是让线程获取对象的同步锁。


## **Thread.join()**

> `join()`的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。

在线程ThreadA中执行线程ThreadB.join()方法，那么线程ThreadA之后的代码，在线程ThreadB结束后才会执行。

### **源码**

在ThreadA的run方法里，执行了ThreadB.join();，进入看一下它的JDK源码：
```
public final void join() throws InterruptedException {
    join(0L);
}
```
然后进入join(0L)方法：
```
public final synchronized void join(long l)
    throws InterruptedException
{
    long l1 = System.currentTimeMillis();
    long l2 = 0L;
    if(l < 0L)
        throw new IllegalArgumentException("timeout value is negative");
    if(l == 0L)
        for(; isAlive(); wait(0L));
    else
        do
        {
            if(!isAlive())
                break;
            long l3 = l - l2;
            if(l3 <= 0L)
                break;
            wait(l3);
            l2 = System.currentTimeMillis() - l1;
        } while(true);
}
```

单纯从代码上看： 

* 如果线程被生成了，但还未被起动，isAlive()将返回false，调用它的join()方法是没有作用的。将直接继续向下执行。 

*  
在ThreadA类中的run方法中，ThreadB.join()是判断ThreadB的active状态，如果ThreadB的isActive()方法返回false，在ThreadB.join(),这一点就不用阻塞了，可以继续向下进行了。从源码里看，wait方法中有参数，也就是不用唤醒谁，只是不再执行wait，向下继续执行而已。 

* 在join()方法中，对于isAlive()和wait()方法的作用对象是个比较让人困惑的问题：

isAlive()方法的签名是：public final native boolean isAlive()，也就是说isAlive()是判断当前线程的状态，也就是ThreadB的状态。







