---
layout: post
title:  "内存优化_内存管理机制"
date:   2019-09-15 15:03:00 +0800
categories: Android
tags: 性能优化
author: pepe
description: 『 内存优化_内存管理机制 』
---

### **Java 内存管理机制**

#### **Java 内存分配**

* 方法区：类信息、常量、静态变量(public、final、static)，所有线程共享
* 虚拟机栈：局部变量表、操作数栈
* 本地方法栈：为 native 服务的
* 堆：所有线程共享，对象的实际分配内存都是在堆上的。在虚拟机栈上分配的只是引用，指向在堆中真正创建的对象。

	。 垃圾回收主要是在堆中

* 程序计数器：执行到哪一行

#### **Java 内存回收算法**

* 标记-清除算法

	。 标记处所有需要回收的对象
	。 统一回收所有被标记的对象
	。 -----------------------
	。 标记清除效率不高
	。 产生大量不连续的内存碎片
	
* 复制算法	
	
	。 将内存划分为大小相等的两块
	。 一块内存用完之后复制存活对象到另一块
	。 清理另一块内存
	。 -----------------------
	。 实现简单，运行高效，只需要标记1/2的内存
	。 浪费一半空间，代价大
	
* 标记-整理算法

	。 标记过程与"标记-清除"算法一样
	。 存活对象往一端进行移动
	。 清理其余内存
	。 -----------------------
	。 避免标记-清理导致的内存碎片
	。 避免复制算法的空间浪费
	
* 分代收集算法

	。 结合多种收集算法优势
	。 新生代对象存活率低，复制
	。 老年代对象存活率高，标记-整理

### **Android 内存管理机制**

* 内存弹性分配，分配值与最大值受具体设备影响
* OOM场景：内存真正不足、可用内存不足
* Dalvik 与 Art 区别

	。 Dalvik 仅固定一种回收算法，手机出厂前已经确定好，运行期无法改变
	。 Art 回收算法可运行期选择
	。 Art 具备内存整理能力，减少内存空洞
	
* Low Memory Killer 机制，对所有进程进行回收

	。 进程分类：前台进程、可见进程、服务进程、后台进程、空进程
	。 回收收益
































