---
layout: post
title:  "Proguard混淆 常用规则"
date:   2019-07-18 18:23:00 +0800
categories: Android
tags: 混淆
author: pepe
description: 『 常用规则 』
---

### **通用配置**
```
#代码混淆压缩比，在0~7之间，默认为5，一般不做修改( 表示proguard对你的代码进行迭代优化的次数 )
-optimizationpasses 5

#把混淆类中的方法名也混淆了
-useuniqueclassmembernames

#优化时允许访问并修改有修饰符的类和类的成员
-allowaccessmodification

# 避免混淆内部类、泛型、匿名类
-keepattributes InnerClasses,Signature,EnclosingMethod

#抛出异常时保留代码行号
-keepattributes SourceFile,LineNumberTable

#重命名抛出异常时的文件名称为"SourceFile"
-renamesourcefileattribute SourceFile

#保持所有实现 Serializable 接口的类成员
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

#保留我们使用的四大组件，自定义的Application等等这些类不被混淆
#因为这些子类都有可能被外部调用
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Appliction
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference

#保留support下的所有类及其内部类
-keep class android.support.** {*;}
# 保留继承的support类
-keep public class * extends android.support.v4.**
-keep public class * extends android.support.v7.**
-keep public class * extends android.support.annotation.**

#保留我们自定义控件（继承自View）不被混淆
-keep public class * extends android.view.View{
    *** get*();
    void set*(***);
    public <init>(android.content.Context);
    public <init>(android.content.Context, android.util.AttributeSet);
    public <init>(android.content.Context, android.util.AttributeSet, int);
}

#Fragment不需要在AndroidManifest.xml中注册，需要额外保护下
-keep public class * extends android.app.Fragment

# 保持测试相关的代码
-dontnote junit.framework.**
-dontnote junit.runner.**
-dontwarn android.test.**
-dontwarn android.support.test.**
-dontwarn org.junit.**

#okhttp
-dontwarn com.squareup.okhttp.**
-dontwarn com.squareup.okhttp3.**
-keep class com.squareup.okhttp3.** { *;}
-dontwarn okio.**
#okhttp

#retroift
-dontwarn retrofit2.**
-dontwarn retrofit.**
-keep class retrofit2.** { *; }
-keep class retrofit.** { *; }
-keepattributes Signature
-keepattributes Exceptions
#retroift

## gson[version 2.8.0]
-keep class sun.misc.Unsafe { *; }
-keep class com.google.gson.stream.** { *; }
-keep class com.google.gson.examples.android.model.** { *; }
-keep class * implements com.google.gson.TypeAdapterFactory
-keep class * implements com.google.gson.JsonSerializer
-keep class * implements com.google.gson.JsonDeserializer
## gson

##Glide
-dontwarn com.bumptech.glide.**
-keep class com.bumptech.glide.**{*;}
-keep public class * implements com.bumptech.glide.module.GlideModule
-keep public class * extends com.bumptech.glide.AppGlideModule
-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
  **[] $VALUES;
  public *;
}
# 从glide4.0开始，GifDrawable没有提供getDecoder()方法，
# 需要通过反射获取gifDecoder字段值，所以需要保持GifFrameLoader和GifState类不被混淆
-keep class com.bumptech.glide.load.resource.gif.GifDrawable$GifState{*;}
-keep class com.bumptech.glide.load.resource.gif.GifFrameLoader {*;}
##Glide

##universal-image-loader
-keep class com.nostra13.universalimageloader.** {*;}
-dontwarn com.nostra13.universalimageloader.**
```

### **1. 实体类需要保留**
我们需要保留实体类的get和set方法(反射会用到)，boolean类型的get方法是isXXX，不要忘记保留。
```
 -keep public class com.dev.example.entity.** {
    public void set*(***);
    public *** get*();
    public *** is*();
  }
```
如果所有的实体类在一个包下的话，上面的配置只用写一遍就可以了。可是实际中我们更多的是以业务来划分包名的，于是我们还可以这样配置(实体类的类名一定要含有"Model")
```
-keep public class **.*Model*.** {
    public void set*(***);
    public *** get*();
    public *** is*();
}
```
### **2. 对内部类的处理**
如果项目中使用了内部类，要对其进行保留。

1. **保留写在某个类里面的所有内部类。**下面表示写在类A里面的内部类都会被保留($符号是用来分割内部类与其母体的标志），什么意思呢，比如类A里面有一个内部类B,而B里面也有个内部类C，这时，B和C都会被保留，以此类推，对多重嵌套的情况，都会被保留(当然我们写代码也不会写出这么深层级的内部类出来)，这里的内部类包含静态内部类，非静态内部类，不包含匿名内部类，如果是匿名内部类，只会保留其方法和成员变量（其继承的类或实现的接口的名字会被混淆），另外如果对应的类被保留，在该类里面定义的接口也会被保留，{*;}匹配该类里面的所有部分。
```
-keep class com.dev.example.A$* { *; }
```
2. **保留写在某个内部类里面所有的内部类。**这话听着有点绕口，举个例子，类A里面有个内部类B，下面表示写在类B里面的内部类都会被保留。此时，类B像上面第一点所举得类A一样，有点递归意思在里面。还有就是此时类B的名字不会被混淆，但里面的方法和成员变量会被混淆，如果其它地方没有对类B的方法和成员变量进行保留的话。
```
-keep class com.dev.example.A$B$* { *; }
```

### **3. 对webView进行处理**
```
-keepclassmembers class fqcn.of.javascript.interface.for.webview {
    public *;
}
-keepclassmembers class * extends android.webkit.webViewClient {
    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);
    public boolean *(android.webkit.WebView, java.lang.String);
}
-keepclassmembers class * extends android.webkit.webViewClient {
    public void *(android.webkit.webView, jav.lang.String);
}
```
### **4. 保留js调用的原生方法**
如果我们的app中涉及到和h5交互，需要保留js调用的原生方法。
```
# Keep JavascriptInterface
-keepclassmembers class ** {
    @android.webkit.JavascriptInterface public *;
}
```
### **5. 对含有反射类的处理**
有时候项目中有些类不是实体类，但仍然用到反射功能,如Class.forName("xxx")，这是我们需要保留的。比如这些类在com.dev.example包下，可以通过下面的配置进行保留。
```
-keep class com.dev.example.* { *; }
```
另外上面只是保留了该包下的类，如果该包下还有子包，则子包的类仍然会被混淆，
如果想保留该包下子包的类，我们可以如下配置（**能匹配本包和所含子包，其中子包也可以含有子包）
```
-keep class com.dev.example.**{ *; }
```









































参考：

[Android 开发应该掌握的 Proguard 技巧](https://mp.weixin.qq.com/s/sFPnK_nvNQOWRK3rd3XnZw)

[android 防破解, 代码混淆，代码保护 - 晕菜一员 - 博客园](https://www.cnblogs.com/CharlesGrant/p/7544311.html)
 
[混淆规则(常用) - 简书](https://www.jianshu.com/p/b1fede1a7edf)

[关于Android代码混淆的详细讲解 - 码农教程](http://www.manongjc.com/article/1598.html)

