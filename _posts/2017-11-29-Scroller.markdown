---
layout: post
title:  "Scroller"
date:   2017-11-29 14:07:00 +0800
categories: Android
tags: 自定义ViewGroup
author: pepe
description: 自定义ViewGroup.
---

### scrollTo 和 scrollBy
~~~
public class View {  
    ....  
    protected int mScrollX;   //该视图内容相当于视图起始坐标的偏移量   ， X轴 方向      
    protected int mScrollY;   //该视图内容相当于视图起始坐标的偏移量   ， Y轴方向  
    //返回值  
    public final int getScrollX() {  
        return mScrollX;  
    }  
    public final int getScrollY() {  
        return mScrollY;  
    }  
    public void scrollTo(int x, int y) {  
        //偏移位置发生了改变  
        if (mScrollX != x || mScrollY != y) {  
            int oldX = mScrollX;  
            int oldY = mScrollY;  
            mScrollX = x;  //赋新值，保存当前便宜量  
            mScrollY = y;  
            //回调onScrollChanged方法  
            onScrollChanged(mScrollX, mScrollY, oldX, oldY);  
            if (!awakenScrollBars()) {  
                invalidate();  //一般都引起重绘  
            }  
        }  
    }  
    // 看出原因了吧 。。 mScrollX 与 mScrollY 代表我们当前偏移的位置 ， 在当前位置继续偏移(x ,y)个单位  
    public void scrollBy(int x, int y) {  
        scrollTo(mScrollX + x, mScrollY + y);  
    }  
    //...  
} 
~~~
说明：

    1、scrollTo 和 scrollBy 只能改变 View内容 的位置，而不能改变View在布局中的位置。
    2、在滑动过程中，mScrollX 的值总等于 View左边缘 和 View内容左边缘 在水平方向上的距离。
    3、mScrollY 的值总等于 View上边缘 和 View内容上边缘 在垂直方向上的距离。
    4、mScrollX 和 mScrollY 的单位为像素。
    5、如果从左向右滑动，那么 mScrollX 为负值，反之为正值。
    6、如果从上往下滑动，那么 mScrollY 为负值，反之为正值。
    
### Scroller
#### 构造方法
~~~
/** 
 * Create a Scroller with the default duration and interpolator. 
 */  
public Scroller(Context context) {  
    this(context, null);  
}  
  
/** 
 * Create a Scroller with the specified interpolator. If the interpolator is 
 * null, the default (viscous) interpolator will be used. 
 */  
public Scroller(Context context, Interpolator interpolator) {  
    mFinished = true;  
    mInterpolator = interpolator;  
    float ppi = context.getResources().getDisplayMetrics().density * 160.0f;  
    mDeceleration = SensorManager.GRAVITY_EARTH   // g (m/s^2)  
                  * 39.37f                        // inch/meter  
                  * ppi                           // pixels per inch  
                  * ViewConfiguration.getScrollFriction();  
}  
~~~

#### startScroll()
~~~
public void startScroll(int startX, int startY, int dx, int dy, int duration) {  
    mMode = SCROLL_MODE;  
    mFinished = false;  
    mDuration = duration;  
    mStartTime = AnimationUtils.currentAnimationTimeMillis();  
    mStartX = startX;  
    mStartY = startY;  
    mFinalX = startX + dx;  
    mFinalY = startY + dy;  
    mDeltaX = dx;  
    mDeltaY = dy;  
    mDurationReciprocal = 1.0f / (float) mDuration;  
    // This controls the viscous fluid effect (how much of it)  
    mViscousFluidScale = 8.0f;  
    // must be set to 1.0 (used in viscousFluid())  
    mViscousFluidNormalize = 1.0f;  
    mViscousFluidNormalize = 1.0f / viscousFluid(1.0f);  
} 
~~~
从名字上来看，这应该是滚动的方法。但在这个方法中我们只看到了对一些滚动的基本设置动作，比如设置滚动模式，开始时间，持续时间等等，并没有任何对View的滚动操作。
#### computeScrollOffset()
~~~
/** 
 * Call this when you want to know the new location.  If it returns true, 
 * the animation is not yet finished.  loc will be altered to provide the 
 * new location. 
 */   
public boolean computeScrollOffset() {  
    if (mFinished) {  
        return false;  
    }  
  
    int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);  
  
    if (timePassed < mDuration) {  
        switch (mMode) {  
        case SCROLL_MODE:  
            float x = (float)timePassed * mDurationReciprocal;  
  
            if (mInterpolator == null)  
                x = viscousFluid(x);   
            else  
                x = mInterpolator.getInterpolation(x);  
  
            mCurrX = mStartX + Math.round(x * mDeltaX);  
            mCurrY = mStartY + Math.round(x * mDeltaY);  
            break;  
        case FLING_MODE:  
            float timePassedSeconds = timePassed / 1000.0f;  
            float distance = (mVelocity * timePassedSeconds)  
                    - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);  
              
            mCurrX = mStartX + Math.round(distance * mCoeffX);  
            // Pin to mMinX <= mCurrX <= mMaxX  
            mCurrX = Math.min(mCurrX, mMaxX);  
            mCurrX = Math.max(mCurrX, mMinX);  
              
            mCurrY = mStartY + Math.round(distance * mCoeffY);  
            // Pin to mMinY <= mCurrY <= mMaxY  
            mCurrY = Math.min(mCurrY, mMaxY);  
            mCurrY = Math.max(mCurrY, mMinY);  
              
            break;  
        }  
    }  
    else {  
        mCurrX = mFinalX;  
        mCurrY = mFinalY;  
        mFinished = true;  
    }  
    return true;  
} 
~~~
这个方法有两个作用：

    1、判断滚动是否结束，返回值为boolean，true说明滚动尚未完成，false说明滚动已经完成。
    2、如果滚动没结束，那么将下一次刷新界面时要移动的位置赋值给 mCurrX， mCurrX可以通过 mScroller.getCurrX() 获取。
    
说道这里，似乎还是没弄清楚Scroller跟View滚动的联系在哪里？话不多说，看下图：

![Scroller]({{ site.baseurl }}/assets/images/scroller.png)

说明：
    
    1、在你想要执行滚动是，调用 startScroll(),设置滚动参数
    2、刷新界面 invalidate() 或者 postInvalidate()
    3、在View重绘时，会调用 computeScrollOffset()
    4、我们需要来重写此方法，见下文
    5、在 computeScrollOffset() 中，通过 computeScrollOffset() 判断滚动是否完成
    6、没有完成的话，下一次刷新界面需要到达的位置 在computeScrollOffset() 中已经计算完成
    7、保存在mCurrX， mCurrX 里面，可以通过 mScroller.getCurrX() 获取
    8、再次调用 scrollTo() 和 invalidate()，刷新界面，达到动画的效果
    
#### computeScroll()
~~~
@Override
    public void computeScroll() {
        // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑
        if (mScroller.computeScrollOffset()) {
            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            invalidate();
        }
    }   
~~~    
    
    
相关API：
~~~
mScroller.getCurrX() //获取mScroller当前水平滚动的位置  
mScroller.getCurrY() //获取mScroller当前竖直滚动的位置  
mScroller.getFinalX() //获取mScroller最终停止的水平位置  
mScroller.getFinalY() //获取mScroller最终停止的竖直位置  
mScroller.setFinalX(int newX) //设置mScroller最终停留的水平位置，没有动画效果，直接跳到目标位置  
mScroller.setFinalY(int newY) //设置mScroller最终停留的竖直位置，没有动画效果，直接跳到目标位置  
  
//滚动，startX, startY为开始滚动的位置，dx,dy为滚动的偏移量, duration为完成滚动的时间  
mScroller.startScroll(int startX, int startY, int dx, int dy) //使用默认完成时间250ms  
mScroller.startScroll(int startX, int startY, int dx, int dy, int duration)  
  
mScroller.computeScrollOffset() //返回值为boolean，true说明滚动尚未完成，false说明滚动已经完成。这是一个很重要的方法，通常放在View.computeScroll()中，用来判断是否滚动是否结束。  
~~~


参考：

[Android 带你从源码的角度解析Scroller的滚动实现原理 - CSDN博客](http://blog.csdn.net/xiaanming/article/details/17483273)
