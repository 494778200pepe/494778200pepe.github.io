---
layout: post
title:  "原型设计模式"
date:   2019-11-14 10:04:00 +0800
categories: designpatterns
tags: 设计模式
author: pepe
description: 『 原型设计模式 』
---

### **深拷贝和浅拷贝区别是什么？**

* 浅拷贝：基本类型的属性，复制值；引用类型的属性，复制地址，不复制堆内存中的对象。（Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、集合、容器对象、引用对象等都不会拷贝。）

* 深拷贝：基本类型的属性，复制值；引用类型的属性，复制堆内存中的对象。

![DesignPatterns_Prototype1]({{ site.baseurl }}/assets/images/DesignPatterns/DesignPatterns_Prototype1.png)

![DesignPatterns_Prototype2]({{ site.baseurl }}/assets/images/DesignPatterns/DesignPatterns_Prototype2.png)

### **保护性拷贝(defensive copy)**

何为保护性拷贝？看一个例子：

```
public class Person {
 
	private String name;
	private Date birth;
 
	public Person(String name, Date birth) {
		this.name = name;
		this.birth = birth;
	}
 
	public Date getBirth() {
		return birth;
	}
 
	public String getName() {
		return name;
	}
}
```

我们定义了一个Person类，该类的字段均为私有的，同时没有添加可以修改字段的方法(mutator)。这似乎就是一个不可变类(immutable class)，事实真的是这样吗？我们来测试一下。

```
	public static void main(String[] args) {
 
		Person p = new Person("Benson",new Date(1990, 4, 13));
		System.out.println(p.getName());
		System.out.println(p.getBirth().getYear());
		
		Date hole = p.getBirth();
		hole.setYear(2013);
		
		System.out.println(p.getName());
		System.out.println(p.getBirth().getYear());
	}
```

我们看看输出:

```
Benson
1990
Benson
2013
```

从输出可以看出该类并不是一个不可变类。因为该类的内部状态被修改了。问题出在哪呢？关键在于Date类是一个可变类（而String是一个不可变类，可放心使用），当我们在客户端获取Date类的实例引用时，如果就可以对其内部状态进行修改。如上代码所示。
一个解决办法就是使用保护性拷贝。

```
public class Person {
 
...
	public Date getBirth() {
		return new Date(birth.toString());		//保护性拷贝
	}
...
}
```

这里我们修改了getBirth方法，返回一个同原来值相同的新对象。这样，即使客户端获得了该对象的引用，也无法修改person对象的内部状态，从而使该对象不可变。
再次运行测试类:
```
Benson
1990
Benson
1990
```

### **Android源码中的原型模式**

#### **Intent** 

比如有三个activity，从activity1启动到activity2，在启动activity3，而数据需要从activity1中传递到activity3中

activity1:
```
		Intent intent = new Intent(this,Activity2.class);

        intent.putExtra("Params1","Params1");
        intent.putExtra("Params2","Params2");
        intent.putExtra("Params3","Params3");

        startActivity(intent);   
```

activity2:
```
		//默认
		String Params1 = getIntent().getStringExtra("Params1");
        String Params2 = getIntent().getStringExtra("Params2");
        String Params3 = getIntent().getStringExtra("Params3");
        // 又 new 一个 intent

        // 把参数传递
        Intent intent = new Intent(this,Activity3.class);

        intent.putExtra("Params1",Params1);
        intent.putExtra("Params2",Params2);
        intent.putExtra("Params3",Params3);*/
        //原型设计模式拷贝
        Intent intent = (Intent) getIntent().clone();
        intent.setClass(this, Activity3.class);
        startActivity(intent);    
```

源码
```
    @Override
    public Object clone() {
        return new Intent(this);
    }
	
	public Intent(Intent o) {
        //赋值
        this.mAction = o.mAction;
        this.mData = o.mData;
        this.mType = o.mType;
        this.mPackage = o.mPackage;
        this.mComponent = o.mComponent;
        this.mFlags = o.mFlags;
        this.mContentUserHint = o.mContentUserHint;
    }
```

#### **2 . ArrayList**

```
ArrayList list=new ArrayList();
// 有很多数据
ArrayList copyList = (ArrayList) list.clone();
```

源码:
```
  public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();
            //数组拷贝
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;//重置修改次数
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }
```

#### **3 . OkHttp**

```
OkHttpClient client = new OkHttpClient();
client.newBuilder();
```

源码：

```
Builder(OkHttpClient okHttpClient) {
      this.dispatcher = okHttpClient.dispatcher;
      this.proxy = okHttpClient.proxy;
      this.protocols = okHttpClient.protocols;
      this.connectionSpecs = okHttpClient.connectionSpecs;
      this.interceptors.addAll(okHttpClient.interceptors);
      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
      this.eventListenerFactory = okHttpClient.eventListenerFactory;
      this.proxySelector = okHttpClient.proxySelector;
      this.cookieJar = okHttpClient.cookieJar;
      this.internalCache = okHttpClient.internalCache;
      this.cache = okHttpClient.cache;
      this.socketFactory = okHttpClient.socketFactory;
      this.sslSocketFactory = okHttpClient.sslSocketFactory;
      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
      this.hostnameVerifier = okHttpClient.hostnameVerifier;
      this.certificatePinner = okHttpClient.certificatePinner;
      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
      this.authenticator = okHttpClient.authenticator;
      this.connectionPool = okHttpClient.connectionPool;
      this.dns = okHttpClient.dns;
      this.followSslRedirects = okHttpClient.followSslRedirects;
      this.followRedirects = okHttpClient.followRedirects;
      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
      this.connectTimeout = okHttpClient.connectTimeout;
      this.readTimeout = okHttpClient.readTimeout;
      this.writeTimeout = okHttpClient.writeTimeout;
      this.pingInterval = okHttpClient.pingInterval;
    }
```



参考：

[保护性拷贝(defensive copy) - Benson的专栏 - CSDN博客](https://blog.csdn.net/tounaobun/article/details/8607174)

[原型设计模式 - 奋斗&努力 - CSDN博客](https://blog.csdn.net/qq_24675479/article/details/79725799)


设计模式之原型模式 - chenliguan的博客 - CSDN博客
https://blog.csdn.net/chenliguan/article/details/69855738

















