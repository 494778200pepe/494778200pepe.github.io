---
layout: post
title:  "排序算法"
date:   2018-01-30 13:28:00 +0800
categories: Other
tags: Other
author: pepe
description: 排序算法.
---


![排序算法]({{ site.baseurl }}/assets/images/sort1.png)
![算法比较]({{ site.baseurl }}/assets/images/sort2.png)

排序算法稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。

* 堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法
* 基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。

### 选择排序
```
    public static void selectSort(int[] data) {
        if (null == data || data.length == 0) {
            return;
        }
        int k;
        int j;
        for (int i = 0; i < data.length; i++) {
            k = i;
            for (j = i + 1; j < data.length; j++) {
                if (data[k] > data[j]) {
                    k = j;
                }
            }
            if (k != i) {
                int temp = data[i];
                data[i] = data[k];
                data[k] = temp;
            }
        }
    }
```

### 插入排序
```
    public static void insertSort(int[] data) {
        if (null == data || data.length == 0) {
            return;
        }
        int j;
        int target;
        for (int i = 1; i < data.length; i++) {
            j = i;
            target = data[i];
            while (j > 0 && target < data[j - 1]) {
                data[j] = data[j - 1];
                j--;
            }
            data[j] = target;
        }
    }
```

### 折半插入排序
```
    public static void binaryInsertSort(int[] data) {
        for (int i = 1; i < data.length; i++) {
            int temp = data[i];
            int low = 0;
            int high = i - 1;
            while (low <= high) {
                int mid = (low + high) / 2;
                if (temp < data[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            for (int j = i; j >= low + 1; j--) {
                data[j] = data[j - 1];
            }
            data[low] = temp;
        }
    }
```








